<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像背景切り抜きツール (ブラウザ版・自動トリミング対応)</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 800px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; }
        input[type="file"] { display: block; margin: 15px auto; }
        button {
            display: block; margin: 10px auto; padding: 10px 20px; font-size: 16px;
            cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px;
        }
        button:disabled { background-color: #ccc; }
        .image-container { display: flex; justify-content: space-around; margin-top: 20px; flex-wrap: wrap; }
        .image-box { border: 1px solid #ccc; padding: 10px; margin:10px; width: calc(50% - 42px); min-width: 250px; box-sizing: border-box;}
        .image-box h2 { font-size: 1em; text-align: center; margin-bottom: 10px;}
        img { max-width: 100%; max-height: 300px; display: block; margin: 0 auto; object-fit: contain; /* 追加 */ }
        #loading { display: none; text-align: center; margin-top: 15px; font-weight: bold; }
        #downloadLink {
            display: none; margin: 15px auto; padding: 10px 20px; background-color: #28a745; color: white;
            text-decoration: none; border-radius: 5px; text-align: center; width: fit-content;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>画像背景切り抜きツール (ブラウザ版・自動トリミング対応)</h1>
        <p style="text-align:center;">背景を切り取りたい画像を選択してください。</p>
        <input type="file" id="imageUpload" accept="image/*">

        <fieldset style="margin-top: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px;">
            <legend>オプション: スクリーンショットからアイテム領域を切り抜く</legend>
            <p style="font-size: 0.9em; color: #555;">
                ゲームのスクリーンショット全体をアップロードした場合、ここをチェックして切り抜く座標を指定してください。<br>
                (左上のX, 左上のY, 幅, 高さ) の形式で入力します。
            </p>
            <input type="checkbox" id="enableCrop">
            <label for="enableCrop">指定範囲を切り抜いてから背景除去する</label><br>
            <div id="cropSettings" style="display:none; margin-top:10px;">
                X: <input type="number" id="cropX" placeholder="例: 780" style="width:60px;">
                Y: <input type="number" id="cropY" placeholder="例: 85" style="width:60px;"><br>
                幅: <input type="number" id="cropWidth" placeholder="例: 425" style="width:60px;">
                高さ: <input type="number" id="cropHeight" placeholder="例: 320" style="width:60px;">
            </div>
        </fieldset>

        <button id="processImageBtn">背景を切り抜く＆自動トリミング</button> <!-- ▼変更点▼ ボタンテキスト変更 -->
        <p id="loading">処理中...</p>

        <div class="image-container">
            <div class="image-box">
                <h2>元画像 (または初期切り抜き後)</h2>
                <img id="originalImagePreview" src="#" alt="元画像">
            </div>
            <div class="image-box">
                <h2>最終結果 (背景切り抜き＆自動トリミング後)</h2> <!-- ▼変更点▼ 見出し変更 -->
                <img id="resultImage" src="#" alt="切り抜き後の画像">
            </div>
        </div>
        <a id="downloadLink" href="#" download="processed_item.png">画像をダウンロード</a>
    </div>

    <script type="module">
        import { removeBackground } from 'https://cdn.jsdelivr.net/npm/@picflow/background-removal@latest/dist/index.esm.js';

        const imageUpload = document.getElementById('imageUpload');
        const originalImagePreview = document.getElementById('originalImagePreview');
        const resultImage = document.getElementById('resultImage');
        const processImageBtn = document.getElementById('processImageBtn');
        const loadingText = document.getElementById('loading');
        const downloadLink = document.getElementById('downloadLink');

        const enableCropCheckbox = document.getElementById('enableCrop');
        const cropSettingsDiv = document.getElementById('cropSettings');
        const cropXInput = document.getElementById('cropX');
        const cropYInput = document.getElementById('cropY');
        const cropWidthInput = document.getElementById('cropWidth');
        const cropHeightInput = document.getElementById('cropHeight');

        let currentFile = null;

        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                currentFile = file;
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImagePreview.src = e.target.result;
                    originalImagePreview.style.display = 'block';
                }
                reader.readAsDataURL(file);
                resultImage.src = "#";
                resultImage.style.display = 'none';
                downloadLink.style.display = 'none';
            }
        });

        enableCropCheckbox.addEventListener('change', () => {
            cropSettingsDiv.style.display = enableCropCheckbox.checked ? 'block' : 'none';
        });

        // ▼変更点▼ 自動トリミング関数を追加
        async function cropToContent(imageBlob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

                        // 透明でないピクセルの境界を見つける
                        for (let y = 0; y < canvas.height; y++) {
                            for (let x = 0; x < canvas.width; x++) {
                                const alpha = data[(y * canvas.width + x) * 4 + 3]; // Alpha channel
                                if (alpha > 20) { // ある程度の不透明度を持つピクセルを対象 (閾値は調整可能)
                                    if (x < minX) minX = x;
                                    if (x > maxX) maxX = x;
                                    if (y < minY) minY = y;
                                    if (y > maxY) maxY = y;
                                }
                            }
                        }

                        if (maxX < minX || maxY < minY) { // 画像が完全に透明、または検出できなかった場合
                            resolve(imageBlob); // 元のBlobを返す
                            return;
                        }

                        const cropWidth = maxX - minX + 1;
                        const cropHeight = maxY - minY + 1;

                        const cropCanvas = document.createElement('canvas');
                        cropCanvas.width = cropWidth;
                        cropCanvas.height = cropHeight;
                        const cropCtx = cropCanvas.getContext('2d');
                        cropCtx.drawImage(canvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                        cropCanvas.toBlob(blob => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas toBlob failed during auto-crop'));
                            }
                        }, 'image/png');
                    } catch (e) {
                        console.error("Error during pixel manipulation for auto-crop:", e);
                        reject(new Error('Error during auto-crop pixel processing.'));
                    }
                };
                img.onerror = () => reject(new Error('Image loading for auto-crop failed'));
                img.src = URL.createObjectURL(imageBlob);
            });
        }
        // ▲変更点▲ 自動トリミング関数

        processImageBtn.addEventListener('click', async () => {
            if (!currentFile) {
                alert('まず画像を選択してください。');
                return;
            }

            loadingText.style.display = 'block';
            processImageBtn.disabled = true;
            resultImage.style.display = 'none';
            downloadLink.style.display = 'none';

            try {
                let imageToProcess = currentFile;

                if (enableCropCheckbox.checked) {
                    const x = parseInt(cropXInput.value);
                    const y = parseInt(cropYInput.value);
                    const width = parseInt(cropWidthInput.value);
                    const height = parseInt(cropHeightInput.value);

                    if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                        alert('切り抜く範囲の座標とサイズを正しく入力してください。');
                        throw new Error('Invalid crop dimensions');
                    }

                    const croppedBlob = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
                            canvas.toBlob(blob => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Canvas toBlob failed'));
                                }
                            }, currentFile.type || 'image/png');
                        };
                        img.onerror = () => reject(new Error('Image loading for crop failed'));
                        img.src = URL.createObjectURL(currentFile);
                    });
                    imageToProcess = croppedBlob;
                    originalImagePreview.src = URL.createObjectURL(imageToProcess); // 初期切り抜き後をプレビュー
                } else {
                    // 初期切り抜きしない場合は、アップロードされた画像をそのままプレビュー
                    originalImagePreview.src = URL.createObjectURL(currentFile);
                }

                // 1. 背景除去
                const bgRemovedBlob = await removeBackground(imageToProcess);

                // 2. 背景除去後の画像を自動トリミング ▼変更点▼
                const finalTrimmedBlob = await cropToContent(bgRemovedBlob);
                // ▲変更点▲

                const resultUrl = URL.createObjectURL(finalTrimmedBlob); // ▼変更点▼ finalTrimmedBlobを使用
                resultImage.src = resultUrl;
                resultImage.style.display = 'block';

                downloadLink.href = resultUrl;
                downloadLink.style.display = 'block';

            } catch (error) {
                console.error('処理エラー:', error);
                alert('画像の処理に失敗しました。コンソールで詳細を確認してください。\nエラー: ' + error.message);
            } finally {
                loadingText.style.display = 'none';
                processImageBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
